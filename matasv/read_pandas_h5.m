function data = read_pandas_h5(filename)
%% A function to read HDF5 files generated by pandas
%
% Val Schmidt
% CCOM/JHC
% 2018

if isempty(filename)
   filename = uigetfile('.');
end

% Get file metadata
M = h5info(filename);

% FIX: Check for this...
filetype = 'table';

% Extract the DataFrame names
% Each DataFrame in the h5 file will be encoded as a "Group"
Groups = {M.Groups.Name};

name = Groups{1}(2:end);
data.name = replace(name,'/','_');

if strcmp(filetype,'fixed')

    %% to_hdf(....forat='fixed')
    % If data is written in the 'fixed' format, then text portions of the
    % DataFrame will be written as python objects which appear as binary blobs
    % within the hdf file. These are uninterpretable by MATLAB (at least not
    % without considerable pain) and will be omitted from reading.
    
    % Extract the field names for each column in the data set.
    % fieldnamelist = h5read(filename,[Groups{1} '/block0_items']);
    
    % Read the data (transpose it as its written in rows)
    % values = h5read(filename,[Groups{1} '/block0_values'])';

end

if strcmp(filetype,'table')
%% to_hdf(....format='table')
% For format='table' generated files from pandas (pytables format), text
% data is written, (and can be read by MATLAB) as a character array. This
% line reads all the data. 
values = h5read(filename,[Groups{1} '/table']);


GroupDataSetsAttributesNames = {M.Groups.Datasets.Attributes.Name};
GroupDataSetsAttributesValues = {M.Groups.Datasets.Attributes.Value};

STRINGDATA = false;

% The data in the file is organized roughly into blocks of common type.
% Each of these is called a data "block". So for each data block,
% we need to extract the field names for the columns of that block, and
% if the block is of type "string" we need to do some special handling.
% The metadata is extracted by MATLAB into two cell arrays, one containing
% the type of metadata and the second containing the metadata values. 
% Unfortunately, we cannot rely on the order of these entries being the
% same, so we have to look for the fields we want. 

% For each data block, the column names are listed in a metadata field
% called 'values_block_DD_kind', where DD is an integer indicating one of
% the blocks of data. 

% This bit of code searches the metadata fieldnames and extracts the data
% block index (the DD above), and the indices of the cell array entries where the
% column names can be found for that data block. 
tmp = regexp(GroupDataSetsAttributesNames,'values_block_(\d+)_kind','tokens');
column_name_indices = find(cellfun(@(x) ~isempty(x),(regexp(GroupDataSetsAttributesNames,['values.*kind']))));
ctr = 1;
for i=1:length(tmp)
    if ~isempty(tmp{i})
        blocknumber{ctr} = tmp{i}{1}{1};
        ctr = ctr + 1;
    end
end

% Now we loop through each data block by it's block index. (blocknumber)
for i=1:length(blocknumber)
   
    % For each block, we need it's type, so we search the metadata names
    % cell array for the 'dtype' entry for that block number.
    type_index = find(strcmp(GroupDataSetsAttributesNames,['values_block_' blocknumber{i} '_dtype']));
    
    % Check to see if it's a string, because we extract the data
    % differently for strings than numerica data.
    if regexp(GroupDataSetsAttributesValues{type_index},'^string')
        STRINGDATA = true;
    else
        STRINGDATA = false;
    end
    
    
    % Extract the field names for the block from the pythonic text.
    blockfieldnames = extract_text_from_python(GroupDataSetsAttributesValues(column_name_indices(i)));

        % Loop through the column names and allocate columns to named
        % fields in the output data structure.  
        for q=1:length(blockfieldnames)
            
            % Generate the BlockGroupName which is how each data block is
            % named when extracted from the hdf5 file.
            BlockGroupName = ['values_block_' blocknumber{i}];
            
            % Finally, copy the data read from the hdf5 file to the output
            % data structure, whose field name is given by the column name
            % in the hdf5 table. Handle strings differently since they come
            % in a 3D matrix of chars.
            if STRINGDATA
                % Handle when there is more than one column of strings
                % which produces a 3D matrix of characters.
                if ndims(values.(BlockGroupName)) == 2
                    data.(blockfieldnames{q}) = values.(BlockGroupName)';                
                elseif ndims(values.(BlockGroupName)) == 3
                    data.(blockfieldnames{q}) = squeeze(values.(BlockGroupName)(:,q,:))';
                end
            else
                data.(blockfieldnames{q}) = values.(BlockGroupName)(q,:)';
            end
        end
end




end

end


function output = extract_text_from_python(input)

% Remove single quotes which confound me, and add a unique delimiter.
tmp = strrep(input,'''','%%%');
% Remove all other odd characters, but keep the delimiter.
tmp = regexprep(tmp,'[^a-zA-Z_0-9%]+','');
% Split on delimiter.
tmp2 = regexp(tmp,'%%%(\w+)%%%','tokens');
% Pull results out of embedded cell.
for i=1:length(tmp2{1})
    output{i} = tmp2{1}{i}{1};
end

end